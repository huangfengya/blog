## 数据存储

基本数据类型用 栈 存储，引用数据类型用 堆 存储；但是闭包变量是存在 堆 中的。

所以对于赋值操作，几倍数据类型是完整的复制变量值，引用数据类型的数据则是复制引用地址，所以改变引用类型的值，相同内存中的值也会改变。

## 垃圾回收

js 语言不像 c/c++ 让程序员自己开辟或则释放内存，而是类似 Java，采用一套自己的垃圾回收算法进行自动的内存管理

### V8 内存限制

V8 不像 Java/Go 对内存的使用没有什么限制，64 位系统下最多只能分配 1.4G 内存，32 位系统只有 0.7G，也就是说如果有个大于 1.6G 的文件，是不能将其全部读入内存进行各种操作。之所以有限制一是因为JS是单线程的，一段进入到垃圾回收，那么其他的各种逻辑都会暂停；二是垃圾回收实际上是非常耗时间的，如果过大就会导致应用卡顿。

### 新生代内存的回收

V8 把堆内存分为了两部分进行处理：新生代和老生代内存。新生代内存就是临时分配的内存，存活时间短；老生代是常驻内存，存活时间长。V8 的堆内存，也就是两个内存的和。

由于新生代内存的变量存活时间比较短，所以内存比较小：64 位为 32MB，32 位为 16MB。

首先将新生代内存分为两部分：From 表示正在使用的内存，To 表示闲置的内存。

当进行垃圾回收时，V8 将 From 的对象全部检查一遍，如果是存活对象就复制到 To 内存中(在 To 内存中按照顺序重头放置)，如果是非存活对象，则直接回收。

当所有的存活对象进入到 To 内存后，From 和 To 角色互调，From 被闲置，To 正在使用，如此循环。

至于为什么不直接将非存活对象回收而是移动到闲置内存，是因为堆内存是连续分配的，直接回收的话，内存不连续，产生内存碎片，太过于零散可能无法进行新的空间分配，所以通过移动到 To 内存进行重头排序。

### 老生代内存的回收

新生代内存如果经过多次回收后依然存在，那么就会将其晋升到老生代内存中。

触发晋升的条件：
1. 已经经历过一次内存回收
2. To 内存占用超过 25%

第一步：标记-清除
    主要是分为两个阶段，标记阶段：首先遍历堆中的对象，给他们做上标记，然后对代码环境中使用的变量以及强引用的变量取消标记，剩下的就是要删除的变量了。
    清除阶段：就是直接对有标记的变量进行回收，当然这又会引起内存碎片
    
第二步：整理内存碎片
    简单粗暴：直接把所有的数据往一端靠拢，所以这一步也是最浪费时间的做法

#### 增量标记

由于 js 是单线程，所以如果需要整理的碎片比较多的话，会不可避免的阻塞业务逻辑的执行，所以采取了增量标记的方案，将标记任务分成多个小份去执行，每次执行完一个小份，就执行应用逻辑，然后再执行剩下的任务，知道所有的内存碎片整理完成